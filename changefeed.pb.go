// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: changefeed.proto

package changefeedpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Op enumerates the types of operations represented in a change event.
type Op int32

const (
	Op_OP_UNSPECIFIED Op = 0
	Op_OP_CREATE      Op = 1
	Op_OP_UPDATE      Op = 2
	Op_OP_DELETE      Op = 3
)

var Op_name = map[int32]string{
	0: "OP_UNSPECIFIED",
	1: "OP_CREATE",
	2: "OP_UPDATE",
	3: "OP_DELETE",
}

var Op_value = map[string]int32{
	"OP_UNSPECIFIED": 0,
	"OP_CREATE":      1,
	"OP_UPDATE":      2,
	"OP_DELETE":      3,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{0}
}

// MessageBatch is a batch of messages for use in webhook sinks.
type MessageBatch struct {
	Payload []*Message `protobuf:"bytes,1,rep,name=payload,proto3" json:"payload,omitempty"`
}

func (m *MessageBatch) Reset()         { *m = MessageBatch{} }
func (m *MessageBatch) String() string { return proto.CompactTextString(m) }
func (*MessageBatch) ProtoMessage()    {}
func (*MessageBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{0}
}
func (m *MessageBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MessageBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageBatch.Merge(m, src)
}
func (m *MessageBatch) XXX_Size() int {
	return m.Size()
}
func (m *MessageBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageBatch.DiscardUnknown(m)
}

var xxx_messageInfo_MessageBatch proto.InternalMessageInfo

// Message is an enum of the different envelope types. This is what will be emitted to the client.
type Message struct {
	// Types that are valid to be assigned to Data:
	//	*Message_Wrapped
	//	*Message_Bare
	//	*Message_Enriched
	//	*Message_Resolved
	//	*Message_BareResolved
	Data isMessage_Data `protobuf_oneof:"data"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{1}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type isMessage_Data interface {
	isMessage_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Message_Wrapped struct {
	Wrapped *WrappedEnvelope `protobuf:"bytes,1,opt,name=wrapped,proto3,oneof" json:"wrapped,omitempty"`
}
type Message_Bare struct {
	Bare *BareEnvelope `protobuf:"bytes,2,opt,name=bare,proto3,oneof" json:"bare,omitempty"`
}
type Message_Enriched struct {
	Enriched *EnrichedEnvelope `protobuf:"bytes,3,opt,name=enriched,proto3,oneof" json:"enriched,omitempty"`
}
type Message_Resolved struct {
	Resolved *Resolved `protobuf:"bytes,4,opt,name=resolved,proto3,oneof" json:"resolved,omitempty"`
}
type Message_BareResolved struct {
	BareResolved *BareResolved `protobuf:"bytes,5,opt,name=bareResolved,proto3,oneof" json:"bareResolved,omitempty"`
}

func (*Message_Wrapped) isMessage_Data()      {}
func (*Message_Bare) isMessage_Data()         {}
func (*Message_Enriched) isMessage_Data()     {}
func (*Message_Resolved) isMessage_Data()     {}
func (*Message_BareResolved) isMessage_Data() {}

func (m *Message) GetData() isMessage_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetWrapped() *WrappedEnvelope {
	if x, ok := m.GetData().(*Message_Wrapped); ok {
		return x.Wrapped
	}
	return nil
}

func (m *Message) GetBare() *BareEnvelope {
	if x, ok := m.GetData().(*Message_Bare); ok {
		return x.Bare
	}
	return nil
}

func (m *Message) GetEnriched() *EnrichedEnvelope {
	if x, ok := m.GetData().(*Message_Enriched); ok {
		return x.Enriched
	}
	return nil
}

func (m *Message) GetResolved() *Resolved {
	if x, ok := m.GetData().(*Message_Resolved); ok {
		return x.Resolved
	}
	return nil
}

func (m *Message) GetBareResolved() *BareResolved {
	if x, ok := m.GetData().(*Message_BareResolved); ok {
		return x.BareResolved
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Message) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Message_Wrapped)(nil),
		(*Message_Bare)(nil),
		(*Message_Enriched)(nil),
		(*Message_Resolved)(nil),
		(*Message_BareResolved)(nil),
	}
}

// WrappedEnvelope includes both the changed data and contextual metadata about the change.
type WrappedEnvelope struct {
	After         *Record `protobuf:"bytes,1,opt,name=after,proto3" json:"after,omitempty"`
	Before        *Record `protobuf:"bytes,2,opt,name=before,proto3" json:"before,omitempty"`
	Updated       string  `protobuf:"bytes,4,opt,name=updated,proto3" json:"updated,omitempty"`
	MvccTimestamp string  `protobuf:"bytes,5,opt,name=mvcc_timestamp,json=mvccTimestamp,proto3" json:"mvcc_timestamp,omitempty"`
	Key           *Key    `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
	Topic         string  `protobuf:"bytes,7,opt,name=topic,proto3" json:"topic,omitempty"`
}

func (m *WrappedEnvelope) Reset()         { *m = WrappedEnvelope{} }
func (m *WrappedEnvelope) String() string { return proto.CompactTextString(m) }
func (*WrappedEnvelope) ProtoMessage()    {}
func (*WrappedEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{2}
}
func (m *WrappedEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrappedEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WrappedEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrappedEnvelope.Merge(m, src)
}
func (m *WrappedEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *WrappedEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_WrappedEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_WrappedEnvelope proto.InternalMessageInfo

// BareEnvelope contains change data as a flat map along with
// CockroachDB-specific metadata under the '__crdb__' field.
type BareEnvelope struct {
	Values  map[string]*Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XCrdb__ *Metadata         `protobuf:"bytes,2,opt,name=__crdb__,json=Crdb,proto3" json:"__crdb__,omitempty"`
}

func (m *BareEnvelope) Reset()         { *m = BareEnvelope{} }
func (m *BareEnvelope) String() string { return proto.CompactTextString(m) }
func (*BareEnvelope) ProtoMessage()    {}
func (*BareEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{3}
}
func (m *BareEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BareEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareEnvelope.Merge(m, src)
}
func (m *BareEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *BareEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_BareEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_BareEnvelope proto.InternalMessageInfo

// BareResolved is a minimal envelope that wraps a resolved timestamp in a '__crdb__' field.
type BareResolved struct {
	XCrdb__ *Resolved `protobuf:"bytes,1,opt,name=__crdb__,json=Crdb,proto3" json:"__crdb__,omitempty"`
}

func (m *BareResolved) Reset()         { *m = BareResolved{} }
func (m *BareResolved) String() string { return proto.CompactTextString(m) }
func (*BareResolved) ProtoMessage()    {}
func (*BareResolved) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{4}
}
func (m *BareResolved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BareResolved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BareResolved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BareResolved.Merge(m, src)
}
func (m *BareResolved) XXX_Size() int {
	return m.Size()
}
func (m *BareResolved) XXX_DiscardUnknown() {
	xxx_messageInfo_BareResolved.DiscardUnknown(m)
}

var xxx_messageInfo_BareResolved proto.InternalMessageInfo

// EnrichedEnvelope includes detailed context about the change event and source.
type EnrichedEnvelope struct {
	After  *Record         `protobuf:"bytes,1,opt,name=after,proto3" json:"after,omitempty"`
	Before *Record         `protobuf:"bytes,2,opt,name=before,proto3" json:"before,omitempty"`
	Op     Op              `protobuf:"varint,3,opt,name=op,proto3,enum=changefeedpb.Op" json:"op,omitempty"`
	Key    *Key            `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	TsNs   int64           `protobuf:"varint,5,opt,name=ts_ns,json=tsNs,proto3" json:"ts_ns,omitempty"`
	Source *EnrichedSource `protobuf:"bytes,6,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *EnrichedEnvelope) Reset()         { *m = EnrichedEnvelope{} }
func (m *EnrichedEnvelope) String() string { return proto.CompactTextString(m) }
func (*EnrichedEnvelope) ProtoMessage()    {}
func (*EnrichedEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{5}
}
func (m *EnrichedEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnrichedEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnrichedEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnrichedEnvelope.Merge(m, src)
}
func (m *EnrichedEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *EnrichedEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_EnrichedEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_EnrichedEnvelope proto.InternalMessageInfo

// Resolved carries resolved timestamp information for a changefeed span.
type Resolved struct {
	Resolved string `protobuf:"bytes,1,opt,name=resolved,proto3" json:"resolved,omitempty"`
}

func (m *Resolved) Reset()         { *m = Resolved{} }
func (m *Resolved) String() string { return proto.CompactTextString(m) }
func (*Resolved) ProtoMessage()    {}
func (*Resolved) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{6}
}
func (m *Resolved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resolved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Resolved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resolved.Merge(m, src)
}
func (m *Resolved) XXX_Size() int {
	return m.Size()
}
func (m *Resolved) XXX_DiscardUnknown() {
	xxx_messageInfo_Resolved.DiscardUnknown(m)
}

var xxx_messageInfo_Resolved proto.InternalMessageInfo

// EnrichedSource records information about the origin and context
// of a change event, for operational traceability.
type EnrichedSource struct {
	JobId              string   `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	ChangefeedSink     string   `protobuf:"bytes,2,opt,name=changefeed_sink,json=changefeedSink,proto3" json:"changefeed_sink,omitempty"`
	DbVersion          string   `protobuf:"bytes,3,opt,name=db_version,json=dbVersion,proto3" json:"db_version,omitempty"`
	ClusterName        string   `protobuf:"bytes,4,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	ClusterId          string   `protobuf:"bytes,5,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	SourceNodeLocality string   `protobuf:"bytes,6,opt,name=source_node_locality,json=sourceNodeLocality,proto3" json:"source_node_locality,omitempty"`
	NodeName           string   `protobuf:"bytes,7,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	NodeId             string   `protobuf:"bytes,8,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	MvccTimestamp      string   `protobuf:"bytes,9,opt,name=mvcc_timestamp,json=mvccTimestamp,proto3" json:"mvcc_timestamp,omitempty"`
	TsNs               int64    `protobuf:"varint,10,opt,name=ts_ns,json=tsNs,proto3" json:"ts_ns,omitempty"`
	TsHlc              string   `protobuf:"bytes,11,opt,name=ts_hlc,json=tsHlc,proto3" json:"ts_hlc,omitempty"`
	Origin             string   `protobuf:"bytes,12,opt,name=origin,proto3" json:"origin,omitempty"`
	DatabaseName       string   `protobuf:"bytes,13,opt,name=database_name,json=databaseName,proto3" json:"database_name,omitempty"`
	SchemaName         string   `protobuf:"bytes,14,opt,name=schema_name,json=schemaName,proto3" json:"schema_name,omitempty"`
	TableName          string   `protobuf:"bytes,15,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	PrimaryKeys        []string `protobuf:"bytes,16,rep,name=primary_keys,json=primaryKeys,proto3" json:"primary_keys,omitempty"`
}

func (m *EnrichedSource) Reset()         { *m = EnrichedSource{} }
func (m *EnrichedSource) String() string { return proto.CompactTextString(m) }
func (*EnrichedSource) ProtoMessage()    {}
func (*EnrichedSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{7}
}
func (m *EnrichedSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnrichedSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnrichedSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnrichedSource.Merge(m, src)
}
func (m *EnrichedSource) XXX_Size() int {
	return m.Size()
}
func (m *EnrichedSource) XXX_DiscardUnknown() {
	xxx_messageInfo_EnrichedSource.DiscardUnknown(m)
}

var xxx_messageInfo_EnrichedSource proto.InternalMessageInfo

// Metadata contains CockroachDB-specific metadata about a change event.
// This message is also referred to as '__crdb__'.
type Metadata struct {
	Updated       string `protobuf:"bytes,1,opt,name=updated,proto3" json:"updated,omitempty"`
	MvccTimestamp string `protobuf:"bytes,2,opt,name=mvcc_timestamp,json=mvccTimestamp,proto3" json:"mvcc_timestamp,omitempty"`
	Key           *Key   `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Topic         string `protobuf:"bytes,4,opt,name=topic,proto3" json:"topic,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{8}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

// Value represents a value of arbitrary type carried in a change event.
type Value struct {
	// Types that are valid to be assigned to Value:
	//
	//	*Value_StringValue
	//	*Value_BytesValue
	//	*Value_Int32Value
	//	*Value_Int64Value
	//	*Value_FloatValue
	//	*Value_DoubleValue
	//	*Value_BoolValue
	//	*Value_TimestampValue
	//	*Value_ArrayValue
	//	*Value_TupleValue
	//	*Value_DecimalValue
	//	*Value_DateValue
	//	*Value_IntervalValue
	//	*Value_TimeValue
	//	*Value_UuidValue
	Value isValue_Value `protobuf_oneof:"value"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{9}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type isValue_Value interface {
	isValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Value_StringValue struct {
	StringValue string `protobuf:"bytes,1,opt,name=string_value,json=stringValue,proto3,oneof" json:"string_value,omitempty"`
}
type Value_BytesValue struct {
	BytesValue []byte `protobuf:"bytes,2,opt,name=bytes_value,json=bytesValue,proto3,oneof" json:"bytes_value,omitempty"`
}
type Value_Int32Value struct {
	Int32Value int32 `protobuf:"varint,3,opt,name=int32_value,json=int32Value,proto3,oneof" json:"int32_value,omitempty"`
}
type Value_Int64Value struct {
	Int64Value int64 `protobuf:"varint,4,opt,name=int64_value,json=int64Value,proto3,oneof" json:"int64_value,omitempty"`
}
type Value_FloatValue struct {
	FloatValue float32 `protobuf:"fixed32,5,opt,name=float_value,json=floatValue,proto3,oneof" json:"float_value,omitempty"`
}
type Value_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,6,opt,name=double_value,json=doubleValue,proto3,oneof" json:"double_value,omitempty"`
}
type Value_BoolValue struct {
	BoolValue bool `protobuf:"varint,7,opt,name=bool_value,json=boolValue,proto3,oneof" json:"bool_value,omitempty"`
}
type Value_TimestampValue struct {
	TimestampValue *types.Timestamp `protobuf:"bytes,8,opt,name=timestamp_value,json=timestampValue,proto3,oneof" json:"timestamp_value,omitempty"`
}
type Value_ArrayValue struct {
	ArrayValue *Array `protobuf:"bytes,9,opt,name=array_value,json=arrayValue,proto3,oneof" json:"array_value,omitempty"`
}
type Value_TupleValue struct {
	TupleValue *Record `protobuf:"bytes,10,opt,name=tuple_value,json=tupleValue,proto3,oneof" json:"tuple_value,omitempty"`
}
type Value_DecimalValue struct {
	DecimalValue *Decimal `protobuf:"bytes,11,opt,name=decimal_value,json=decimalValue,proto3,oneof" json:"decimal_value,omitempty"`
}
type Value_DateValue struct {
	DateValue string `protobuf:"bytes,12,opt,name=date_value,json=dateValue,proto3,oneof" json:"date_value,omitempty"`
}
type Value_IntervalValue struct {
	IntervalValue string `protobuf:"bytes,13,opt,name=interval_value,json=intervalValue,proto3,oneof" json:"interval_value,omitempty"`
}
type Value_TimeValue struct {
	TimeValue string `protobuf:"bytes,14,opt,name=time_value,json=timeValue,proto3,oneof" json:"time_value,omitempty"`
}
type Value_UuidValue struct {
	UuidValue string `protobuf:"bytes,15,opt,name=uuid_value,json=uuidValue,proto3,oneof" json:"uuid_value,omitempty"`
}

func (*Value_StringValue) isValue_Value()    {}
func (*Value_BytesValue) isValue_Value()     {}
func (*Value_Int32Value) isValue_Value()     {}
func (*Value_Int64Value) isValue_Value()     {}
func (*Value_FloatValue) isValue_Value()     {}
func (*Value_DoubleValue) isValue_Value()    {}
func (*Value_BoolValue) isValue_Value()      {}
func (*Value_TimestampValue) isValue_Value() {}
func (*Value_ArrayValue) isValue_Value()     {}
func (*Value_TupleValue) isValue_Value()     {}
func (*Value_DecimalValue) isValue_Value()   {}
func (*Value_DateValue) isValue_Value()      {}
func (*Value_IntervalValue) isValue_Value()  {}
func (*Value_TimeValue) isValue_Value()      {}
func (*Value_UuidValue) isValue_Value()      {}

func (m *Value) GetValue() isValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetStringValue() string {
	if x, ok := m.GetValue().(*Value_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Value) GetBytesValue() []byte {
	if x, ok := m.GetValue().(*Value_BytesValue); ok {
		return x.BytesValue
	}
	return nil
}

func (m *Value) GetInt32Value() int32 {
	if x, ok := m.GetValue().(*Value_Int32Value); ok {
		return x.Int32Value
	}
	return 0
}

func (m *Value) GetInt64Value() int64 {
	if x, ok := m.GetValue().(*Value_Int64Value); ok {
		return x.Int64Value
	}
	return 0
}

func (m *Value) GetFloatValue() float32 {
	if x, ok := m.GetValue().(*Value_FloatValue); ok {
		return x.FloatValue
	}
	return 0
}

func (m *Value) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*Value_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *Value) GetBoolValue() bool {
	if x, ok := m.GetValue().(*Value_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *Value) GetTimestampValue() *types.Timestamp {
	if x, ok := m.GetValue().(*Value_TimestampValue); ok {
		return x.TimestampValue
	}
	return nil
}

func (m *Value) GetArrayValue() *Array {
	if x, ok := m.GetValue().(*Value_ArrayValue); ok {
		return x.ArrayValue
	}
	return nil
}

func (m *Value) GetTupleValue() *Record {
	if x, ok := m.GetValue().(*Value_TupleValue); ok {
		return x.TupleValue
	}
	return nil
}

func (m *Value) GetDecimalValue() *Decimal {
	if x, ok := m.GetValue().(*Value_DecimalValue); ok {
		return x.DecimalValue
	}
	return nil
}

func (m *Value) GetDateValue() string {
	if x, ok := m.GetValue().(*Value_DateValue); ok {
		return x.DateValue
	}
	return ""
}

func (m *Value) GetIntervalValue() string {
	if x, ok := m.GetValue().(*Value_IntervalValue); ok {
		return x.IntervalValue
	}
	return ""
}

func (m *Value) GetTimeValue() string {
	if x, ok := m.GetValue().(*Value_TimeValue); ok {
		return x.TimeValue
	}
	return ""
}

func (m *Value) GetUuidValue() string {
	if x, ok := m.GetValue().(*Value_UuidValue); ok {
		return x.UuidValue
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Value_StringValue)(nil),
		(*Value_BytesValue)(nil),
		(*Value_Int32Value)(nil),
		(*Value_Int64Value)(nil),
		(*Value_FloatValue)(nil),
		(*Value_DoubleValue)(nil),
		(*Value_BoolValue)(nil),
		(*Value_TimestampValue)(nil),
		(*Value_ArrayValue)(nil),
		(*Value_TupleValue)(nil),
		(*Value_DecimalValue)(nil),
		(*Value_DateValue)(nil),
		(*Value_IntervalValue)(nil),
		(*Value_TimeValue)(nil),
		(*Value_UuidValue)(nil),
	}
}

// Key contains the primary key values for a row.
type Key struct {
	Key map[string]*Value `protobuf:"bytes,1,rep,name=key,proto3" json:"key,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{10}
}
func (m *Key) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return m.Size()
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

// Array represents an ordered list of values.
type Array struct {
	Values []*Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *Array) Reset()         { *m = Array{} }
func (m *Array) String() string { return proto.CompactTextString(m) }
func (*Array) ProtoMessage()    {}
func (*Array) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{11}
}
func (m *Array) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Array) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Array) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Array.Merge(m, src)
}
func (m *Array) XXX_Size() int {
	return m.Size()
}
func (m *Array) XXX_DiscardUnknown() {
	xxx_messageInfo_Array.DiscardUnknown(m)
}

var xxx_messageInfo_Array proto.InternalMessageInfo

// Decimal contains a fixed-point decimal value represented as a string.
type Decimal struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Decimal) Reset()         { *m = Decimal{} }
func (m *Decimal) String() string { return proto.CompactTextString(m) }
func (*Decimal) ProtoMessage()    {}
func (*Decimal) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{12}
}
func (m *Decimal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Decimal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal.Merge(m, src)
}
func (m *Decimal) XXX_Size() int {
	return m.Size()
}
func (m *Decimal) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal proto.InternalMessageInfo

// Record represents a flat mapping of column names to values for a row.
type Record struct {
	Values map[string]*Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_c818d38833b16c15, []int{13}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("changefeedpb.Op", Op_name, Op_value)
	proto.RegisterType((*MessageBatch)(nil), "changefeedpb.MessageBatch")
	proto.RegisterType((*Message)(nil), "changefeedpb.Message")
	proto.RegisterType((*WrappedEnvelope)(nil), "changefeedpb.WrappedEnvelope")
	proto.RegisterType((*BareEnvelope)(nil), "changefeedpb.BareEnvelope")
	proto.RegisterMapType((map[string]*Value)(nil), "changefeedpb.BareEnvelope.ValuesEntry")
	proto.RegisterType((*BareResolved)(nil), "changefeedpb.BareResolved")
	proto.RegisterType((*EnrichedEnvelope)(nil), "changefeedpb.EnrichedEnvelope")
	proto.RegisterType((*Resolved)(nil), "changefeedpb.Resolved")
	proto.RegisterType((*EnrichedSource)(nil), "changefeedpb.EnrichedSource")
	proto.RegisterType((*Metadata)(nil), "changefeedpb.Metadata")
	proto.RegisterType((*Value)(nil), "changefeedpb.Value")
	proto.RegisterType((*Key)(nil), "changefeedpb.Key")
	proto.RegisterMapType((map[string]*Value)(nil), "changefeedpb.Key.KeyEntry")
	proto.RegisterType((*Array)(nil), "changefeedpb.Array")
	proto.RegisterType((*Decimal)(nil), "changefeedpb.Decimal")
	proto.RegisterType((*Record)(nil), "changefeedpb.Record")
	proto.RegisterMapType((map[string]*Value)(nil), "changefeedpb.Record.ValuesEntry")
}

func init() { proto.RegisterFile("changefeed.proto", fileDescriptor_c818d38833b16c15) }

var fileDescriptor_c818d38833b16c15 = []byte{
	// 1263 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0x5d, 0x6f, 0xdc, 0x44,
	0x17, 0xc7, 0xd7, 0xfb, 0xee, 0xb3, 0x2f, 0xd9, 0x67, 0xfa, 0xf2, 0x58, 0x81, 0x6e, 0x52, 0x57,
	0xb4, 0xa5, 0x54, 0x9b, 0x2a, 0x8d, 0x4a, 0x81, 0xaa, 0xd0, 0x24, 0x46, 0x1b, 0xa5, 0x24, 0x91,
	0x93, 0x16, 0x89, 0x1b, 0x6b, 0x6c, 0x4f, 0x76, 0xdd, 0x78, 0x3d, 0x96, 0xed, 0x5d, 0xb4, 0x77,
	0x5c, 0x21, 0x21, 0x71, 0x81, 0xf8, 0x2c, 0x7c, 0x88, 0x5e, 0xa1, 0x5e, 0xf6, 0x12, 0x92, 0x0b,
	0xbe, 0x05, 0x42, 0xf3, 0x62, 0xc7, 0xbb, 0x6c, 0x02, 0x12, 0x70, 0xe1, 0x8b, 0xf9, 0xcf, 0xef,
	0x9c, 0x39, 0x73, 0xce, 0x9c, 0x19, 0x43, 0xc7, 0x19, 0xe2, 0x60, 0x40, 0x8e, 0x09, 0x71, 0x7b,
	0x61, 0x44, 0x13, 0x8a, 0x9a, 0xe7, 0x4a, 0x68, 0x2f, 0xaf, 0x0c, 0x28, 0x1d, 0xf8, 0x64, 0x8d,
	0xcf, 0xd9, 0xe3, 0xe3, 0xb5, 0xc4, 0x1b, 0x91, 0x38, 0xc1, 0xa3, 0x50, 0xe0, 0xfa, 0xa7, 0xd0,
	0xfc, 0x82, 0xc4, 0x31, 0x1e, 0x90, 0x4d, 0x9c, 0x38, 0x43, 0xb4, 0x06, 0xb5, 0x10, 0x4f, 0x7d,
	0x8a, 0x5d, 0x4d, 0x59, 0x2d, 0xdd, 0x6d, 0xac, 0x5f, 0xeb, 0xe5, 0x1d, 0xf6, 0x24, 0x6c, 0xa6,
	0x94, 0xfe, 0x53, 0x11, 0x6a, 0x52, 0x44, 0x1f, 0x41, 0xed, 0xeb, 0x08, 0x87, 0x21, 0x61, 0xc6,
	0xca, 0xdd, 0xc6, 0xfa, 0x8d, 0x59, 0xe3, 0x2f, 0xc5, 0xa4, 0x11, 0x4c, 0x88, 0x4f, 0x43, 0xd2,
	0x2f, 0x98, 0x29, 0x8f, 0x1e, 0x40, 0xd9, 0xc6, 0x11, 0xd1, 0x8a, 0xdc, 0x6e, 0x79, 0xd6, 0x6e,
	0x13, 0x47, 0x24, 0x67, 0xc4, 0x49, 0xf4, 0x04, 0xea, 0x24, 0x88, 0x3c, 0x67, 0x48, 0x5c, 0xad,
	0xc4, 0xad, 0xba, 0xb3, 0x56, 0x86, 0x9c, 0xcd, 0x59, 0x66, 0x16, 0x68, 0x03, 0xea, 0x11, 0x89,
	0xa9, 0x3f, 0x21, 0xae, 0x56, 0xe6, 0xd6, 0xd7, 0x67, 0xad, 0x4d, 0x39, 0xcb, 0xac, 0x52, 0x12,
	0x7d, 0x06, 0x4d, 0xb6, 0x76, 0x3a, 0xa7, 0x55, 0x2e, 0x8a, 0x36, 0x67, 0x3d, 0x63, 0xb1, 0x59,
	0x85, 0xb2, 0x8b, 0x13, 0xac, 0xff, 0xa6, 0xc0, 0xd2, 0x5c, 0x3a, 0xd0, 0x3d, 0xa8, 0xe0, 0xe3,
	0x84, 0x44, 0x32, 0x79, 0x57, 0xe7, 0x03, 0x72, 0x68, 0xe4, 0x9a, 0x02, 0x41, 0xf7, 0xa1, 0x6a,
	0x93, 0x63, 0x9a, 0x65, 0x6c, 0x31, 0x2c, 0x19, 0xa4, 0x41, 0x6d, 0x1c, 0xba, 0x38, 0x91, 0x9b,
	0x55, 0xcd, 0x74, 0x88, 0xde, 0x83, 0xf6, 0x68, 0xe2, 0x38, 0x56, 0x76, 0x2e, 0xf8, 0x9e, 0x54,
	0xb3, 0xc5, 0xd4, 0xa3, 0x54, 0x44, 0xb7, 0xa0, 0x74, 0x42, 0xa6, 0x5a, 0x95, 0xaf, 0xf5, 0xbf,
	0xd9, 0xb5, 0x76, 0xc9, 0xd4, 0x64, 0xb3, 0xe8, 0x2a, 0x54, 0x12, 0x1a, 0x7a, 0x8e, 0x56, 0xe3,
	0x2e, 0xc4, 0x40, 0xff, 0x59, 0x81, 0x66, 0xbe, 0x80, 0xe8, 0x29, 0x54, 0x27, 0xd8, 0x1f, 0x93,
	0x58, 0x9e, 0xb0, 0xdb, 0x17, 0x17, 0xbb, 0xf7, 0x92, 0x83, 0x46, 0x90, 0x44, 0x53, 0x53, 0x5a,
	0xa1, 0x1e, 0xd4, 0x2d, 0xcb, 0x89, 0x5c, 0xdb, 0xb2, 0xe4, 0xe6, 0xaf, 0xcf, 0x9f, 0xd1, 0x04,
	0xb3, 0x24, 0x9b, 0xe5, 0xad, 0xc8, 0xb5, 0x97, 0xf7, 0xa0, 0x91, 0x73, 0x83, 0x3a, 0x62, 0x2b,
	0x0a, 0x8f, 0x91, 0xc7, 0xfd, 0x3e, 0x54, 0xb8, 0x6b, 0xe9, 0xed, 0xca, 0xac, 0x37, 0x6e, 0x6b,
	0x0a, 0xe2, 0xe3, 0xe2, 0x63, 0x45, 0x7f, 0x2a, 0xf6, 0x93, 0x96, 0x74, 0x26, 0x1e, 0xe5, 0xb2,
	0xa3, 0x24, 0xe2, 0xd1, 0x7f, 0x57, 0xa0, 0x33, 0x7f, 0x36, 0xff, 0xc3, 0xda, 0xaf, 0x42, 0x91,
	0x86, 0xbc, 0x43, 0xda, 0xeb, 0x9d, 0x59, 0x72, 0x3f, 0x34, 0x8b, 0x34, 0x2b, 0x6e, 0xf9, 0xd2,
	0xe2, 0x5e, 0x81, 0x4a, 0x12, 0x5b, 0x41, 0xcc, 0xcf, 0x47, 0xc9, 0x2c, 0x27, 0xf1, 0x5e, 0x8c,
	0x36, 0xa0, 0x1a, 0xd3, 0x71, 0xe4, 0x10, 0x79, 0x32, 0xde, 0x5d, 0xdc, 0x81, 0x87, 0x9c, 0x31,
	0x25, 0xab, 0xdf, 0x86, 0x7a, 0x96, 0xbc, 0xe5, 0x5c, 0x1f, 0x8a, 0x92, 0x64, 0x63, 0xfd, 0xfb,
	0x32, 0xb4, 0x67, 0x5d, 0xa0, 0x6b, 0x50, 0x7d, 0x45, 0x6d, 0xcb, 0x4b, 0xe1, 0xca, 0x2b, 0x6a,
	0xef, 0xb8, 0xe8, 0x0e, 0x2c, 0x9d, 0x2f, 0x6c, 0xc5, 0x5e, 0x70, 0xc2, 0x53, 0xa3, 0x9a, 0xed,
	0x73, 0xf9, 0xd0, 0x0b, 0x4e, 0xd0, 0x0d, 0x00, 0xd7, 0xb6, 0x26, 0x24, 0x8a, 0x3d, 0x1a, 0xf0,
	0xa4, 0xa8, 0xa6, 0xea, 0xda, 0x2f, 0x85, 0x80, 0x6e, 0x42, 0xd3, 0xf1, 0xc7, 0x71, 0x42, 0x22,
	0x2b, 0xc0, 0x23, 0x22, 0x9b, 0xa5, 0x21, 0xb5, 0x3d, 0x3c, 0x22, 0xcc, 0x43, 0x8a, 0x78, 0xae,
	0x6c, 0x16, 0x55, 0x2a, 0x3b, 0xec, 0x1e, 0xbb, 0x2a, 0x76, 0x69, 0x05, 0xd4, 0x25, 0x96, 0x4f,
	0x1d, 0xec, 0x7b, 0x89, 0xe8, 0x1c, 0xd5, 0x44, 0x62, 0x6e, 0x8f, 0xba, 0xe4, 0xb9, 0x9c, 0x41,
	0xef, 0x80, 0xca, 0x51, 0xbe, 0xa0, 0xe8, 0x9c, 0x3a, 0x13, 0xf8, 0x6a, 0xff, 0x87, 0x1a, 0x9f,
	0xf4, 0x5c, 0xad, 0xce, 0xa7, 0xaa, 0x6c, 0xb8, 0xb3, 0xa8, 0x6f, 0xd5, 0x45, 0x7d, 0x9b, 0x55,
	0x0d, 0x72, 0x55, 0xbb, 0x06, 0xd5, 0x24, 0xb6, 0x86, 0xbe, 0xa3, 0x35, 0x64, 0xa3, 0xc6, 0x7d,
	0xdf, 0x41, 0xd7, 0xa1, 0x4a, 0x23, 0x6f, 0xe0, 0x05, 0x5a, 0x53, 0x2c, 0x25, 0x46, 0xe8, 0x16,
	0xb4, 0x58, 0x37, 0xd9, 0x38, 0x96, 0x41, 0xb6, 0xf8, 0x74, 0x33, 0x15, 0x79, 0xa0, 0x2b, 0xd0,
	0x88, 0x9d, 0x21, 0x19, 0x61, 0x81, 0xb4, 0x39, 0x02, 0x42, 0x4a, 0xf3, 0x96, 0x60, 0xdb, 0x97,
	0x2e, 0x96, 0x44, 0xde, 0xb8, 0xc2, 0xa7, 0x6f, 0x42, 0x33, 0x8c, 0xbc, 0x11, 0x8e, 0xa6, 0xd6,
	0x09, 0x99, 0xc6, 0x5a, 0x67, 0xb5, 0xc4, 0x32, 0x2f, 0xb5, 0x5d, 0x32, 0x8d, 0xf5, 0x6f, 0x15,
	0xa8, 0xa7, 0xad, 0x9d, 0xbf, 0xd1, 0x94, 0xbf, 0xba, 0xd1, 0x8a, 0x97, 0xdc, 0x68, 0xa5, 0xbf,
	0x77, 0xa3, 0x95, 0xf3, 0x37, 0xda, 0x77, 0x15, 0xa8, 0xf0, 0x5b, 0x01, 0xdd, 0x82, 0x66, 0x9c,
	0x44, 0x5e, 0x30, 0xb0, 0xc4, 0x05, 0xc2, 0x43, 0xe9, 0x17, 0xcc, 0x86, 0x50, 0x05, 0x74, 0x13,
	0x1a, 0xf6, 0x34, 0x21, 0xb1, 0x75, 0x7e, 0xc9, 0x34, 0xfb, 0x05, 0x13, 0xb8, 0x98, 0x21, 0x5e,
	0x90, 0x3c, 0x5c, 0x97, 0x08, 0x0b, 0xaa, 0xc2, 0x10, 0x2e, 0xe6, 0x91, 0x47, 0x1b, 0x12, 0x61,
	0x01, 0x95, 0x24, 0xf2, 0x68, 0x23, 0x43, 0x8e, 0x7d, 0x8a, 0x13, 0x89, 0xb0, 0xb3, 0x59, 0x64,
	0x08, 0x17, 0xb3, 0x80, 0x5d, 0x3a, 0x66, 0x65, 0x10, 0x0c, 0x3b, 0x96, 0x0a, 0x0b, 0x58, 0xa8,
	0x02, 0x5a, 0x01, 0xb0, 0x29, 0xf5, 0x25, 0xc2, 0x8e, 0x64, 0xbd, 0x5f, 0x30, 0x55, 0xa6, 0x09,
	0xc0, 0x80, 0xa5, 0x2c, 0xbb, 0x92, 0xaa, 0xcb, 0x97, 0x50, 0xfc, 0x6f, 0xf4, 0xd2, 0xff, 0x8d,
	0x5e, 0x96, 0xf0, 0x7e, 0xc1, 0x6c, 0x67, 0x46, 0xc2, 0xcd, 0x23, 0x68, 0xe0, 0x28, 0xc2, 0x53,
	0xe9, 0x42, 0x5d, 0x74, 0xfb, 0x3e, 0x63, 0x00, 0xdb, 0x04, 0x27, 0x85, 0xdd, 0x87, 0xd0, 0x48,
	0xc6, 0x61, 0xb6, 0x07, 0xb8, 0xf8, 0x12, 0x64, 0x86, 0x1c, 0x15, 0x86, 0x4f, 0xa0, 0xe5, 0x12,
	0xc7, 0x1b, 0xe1, 0x74, 0x6f, 0x0d, 0x6e, 0x3a, 0xf7, 0x8b, 0xb3, 0x2d, 0x10, 0xf6, 0x74, 0x4b,
	0x3a, 0x4b, 0x0b, 0x3b, 0x61, 0xd2, 0xb4, 0x29, 0x4b, 0xad, 0x32, 0x4d, 0x00, 0x77, 0xa0, 0xed,
	0x05, 0x09, 0x89, 0x26, 0x99, 0xff, 0x96, 0x84, 0x5a, 0xa9, 0x9e, 0x79, 0x62, 0xa9, 0x90, 0x50,
	0x3b, 0xf5, 0xc4, 0xb4, 0x0c, 0x18, 0x8f, 0x3d, 0x57, 0x02, 0x4b, 0x29, 0xc0, 0x34, 0x0e, 0x6c,
	0xd6, 0xe4, 0x93, 0xa5, 0x7f, 0xa3, 0x40, 0x69, 0x97, 0x4c, 0xd1, 0xfd, 0xf4, 0x55, 0x2b, 0xfd,
	0xf9, 0x87, 0x64, 0x97, 0x4c, 0xd9, 0x27, 0x5e, 0x51, 0x86, 0x2d, 0xef, 0x42, 0x3d, 0x15, 0xfe,
	0xf9, 0x7b, 0xb8, 0x01, 0x15, 0x5e, 0x25, 0xf4, 0xc1, 0xdc, 0xc3, 0xbe, 0xd0, 0x50, 0x22, 0xfa,
	0x0a, 0xd4, 0x64, 0xa2, 0x59, 0x97, 0xe5, 0xda, 0x47, 0xba, 0xd6, 0x7f, 0x54, 0xa0, 0x2a, 0xaa,
	0x88, 0x1e, 0xcf, 0x39, 0x5e, 0x5d, 0x54, 0xeb, 0x45, 0xff, 0x0a, 0xff, 0xf6, 0xdb, 0x7f, 0xcf,
	0x80, 0xe2, 0x7e, 0x88, 0x10, 0xb4, 0xf7, 0x0f, 0xac, 0x17, 0x7b, 0x87, 0x07, 0xc6, 0xd6, 0xce,
	0xe7, 0x3b, 0xc6, 0x76, 0xa7, 0x80, 0x5a, 0xa0, 0xee, 0x1f, 0x58, 0x5b, 0xa6, 0xf1, 0xec, 0xc8,
	0xe8, 0x28, 0x72, 0xf8, 0xe2, 0x60, 0x9b, 0x0d, 0x8b, 0x72, 0xb8, 0x6d, 0x3c, 0x37, 0x8e, 0x8c,
	0x4e, 0x69, 0xd3, 0x7c, 0xfd, 0x6b, 0xb7, 0xf0, 0xfa, 0xb4, 0xab, 0xbc, 0x39, 0xed, 0x2a, 0x6f,
	0x4f, 0xbb, 0xca, 0x2f, 0xa7, 0x5d, 0xe5, 0x87, 0xb3, 0x6e, 0xe1, 0xcd, 0x59, 0xb7, 0xf0, 0xf6,
	0xac, 0x5b, 0xf8, 0xea, 0xc1, 0xc0, 0x4b, 0x86, 0x63, 0xbb, 0xe7, 0xd0, 0xd1, 0x9a, 0x43, 0x9d,
	0x93, 0x88, 0x62, 0x67, 0xe8, 0xda, 0x6b, 0xf9, 0xf0, 0x3e, 0xc9, 0x0f, 0xec, 0x2a, 0xef, 0xb9,
	0x87, 0x7f, 0x04, 0x00, 0x00, 0xff, 0xff, 0x23, 0x2e, 0x9e, 0xda, 0x13, 0x0c, 0x00, 0x00,
}

func (m *MessageBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChangefeed(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Message_Wrapped) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Wrapped) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Wrapped != nil {
		{
			size, err := m.Wrapped.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Message_Bare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Bare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bare != nil {
		{
			size, err := m.Bare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Message_Enriched) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Enriched) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Enriched != nil {
		{
			size, err := m.Enriched.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Message_Resolved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Resolved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Resolved != nil {
		{
			size, err := m.Resolved.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Message_BareResolved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_BareResolved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BareResolved != nil {
		{
			size, err := m.BareResolved.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *WrappedEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrappedEnvelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrappedEnvelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.MvccTimestamp) > 0 {
		i -= len(m.MvccTimestamp)
		copy(dAtA[i:], m.MvccTimestamp)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.MvccTimestamp)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Updated) > 0 {
		i -= len(m.Updated)
		copy(dAtA[i:], m.Updated)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.Updated)))
		i--
		dAtA[i] = 0x22
	}
	if m.Before != nil {
		{
			size, err := m.Before.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.After != nil {
		{
			size, err := m.After.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BareEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareEnvelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareEnvelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XCrdb__ != nil {
		{
			size, err := m.XCrdb__.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Values) > 0 {
		keysForValues := make([]string, 0, len(m.Values))
		for k := range m.Values {
			keysForValues = append(keysForValues, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
		for iNdEx := len(keysForValues) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Values[string(keysForValues[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChangefeed(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForValues[iNdEx])
			copy(dAtA[i:], keysForValues[iNdEx])
			i = encodeVarintChangefeed(dAtA, i, uint64(len(keysForValues[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChangefeed(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BareResolved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BareResolved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BareResolved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XCrdb__ != nil {
		{
			size, err := m.XCrdb__.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnrichedEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnrichedEnvelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnrichedEnvelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TsNs != 0 {
		i = encodeVarintChangefeed(dAtA, i, uint64(m.TsNs))
		i--
		dAtA[i] = 0x28
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Op != 0 {
		i = encodeVarintChangefeed(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x18
	}
	if m.Before != nil {
		{
			size, err := m.Before.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.After != nil {
		{
			size, err := m.After.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Resolved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resolved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resolved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resolved) > 0 {
		i -= len(m.Resolved)
		copy(dAtA[i:], m.Resolved)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.Resolved)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnrichedSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnrichedSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnrichedSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrimaryKeys) > 0 {
		for iNdEx := len(m.PrimaryKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PrimaryKeys[iNdEx])
			copy(dAtA[i:], m.PrimaryKeys[iNdEx])
			i = encodeVarintChangefeed(dAtA, i, uint64(len(m.PrimaryKeys[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Origin) > 0 {
		i -= len(m.Origin)
		copy(dAtA[i:], m.Origin)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.Origin)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TsHlc) > 0 {
		i -= len(m.TsHlc)
		copy(dAtA[i:], m.TsHlc)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.TsHlc)))
		i--
		dAtA[i] = 0x5a
	}
	if m.TsNs != 0 {
		i = encodeVarintChangefeed(dAtA, i, uint64(m.TsNs))
		i--
		dAtA[i] = 0x50
	}
	if len(m.MvccTimestamp) > 0 {
		i -= len(m.MvccTimestamp)
		copy(dAtA[i:], m.MvccTimestamp)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.MvccTimestamp)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SourceNodeLocality) > 0 {
		i -= len(m.SourceNodeLocality)
		copy(dAtA[i:], m.SourceNodeLocality)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.SourceNodeLocality)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DbVersion) > 0 {
		i -= len(m.DbVersion)
		copy(dAtA[i:], m.DbVersion)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.DbVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChangefeedSink) > 0 {
		i -= len(m.ChangefeedSink)
		copy(dAtA[i:], m.ChangefeedSink)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.ChangefeedSink)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0x22
	}
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MvccTimestamp) > 0 {
		i -= len(m.MvccTimestamp)
		copy(dAtA[i:], m.MvccTimestamp)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.MvccTimestamp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Updated) > 0 {
		i -= len(m.Updated)
		copy(dAtA[i:], m.Updated)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.Updated)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Value_StringValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_StringValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarintChangefeed(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *Value_BytesValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BytesValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesValue != nil {
		i -= len(m.BytesValue)
		copy(dAtA[i:], m.BytesValue)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.BytesValue)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Value_Int32Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Int32Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintChangefeed(dAtA, i, uint64(m.Int32Value))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *Value_Int64Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_Int64Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintChangefeed(dAtA, i, uint64(m.Int64Value))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Value_FloatValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_FloatValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FloatValue))))
	i--
	dAtA[i] = 0x2d
	return len(dAtA) - i, nil
}
func (m *Value_DoubleValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DoubleValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleValue))))
	i--
	dAtA[i] = 0x31
	return len(dAtA) - i, nil
}
func (m *Value_BoolValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_BoolValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *Value_TimestampValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_TimestampValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TimestampValue != nil {
		{
			size, err := m.TimestampValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Value_ArrayValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_ArrayValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ArrayValue != nil {
		{
			size, err := m.ArrayValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Value_TupleValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_TupleValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TupleValue != nil {
		{
			size, err := m.TupleValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Value_DecimalValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DecimalValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DecimalValue != nil {
		{
			size, err := m.DecimalValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChangefeed(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Value_DateValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_DateValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DateValue)
	copy(dAtA[i:], m.DateValue)
	i = encodeVarintChangefeed(dAtA, i, uint64(len(m.DateValue)))
	i--
	dAtA[i] = 0x62
	return len(dAtA) - i, nil
}
func (m *Value_IntervalValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_IntervalValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.IntervalValue)
	copy(dAtA[i:], m.IntervalValue)
	i = encodeVarintChangefeed(dAtA, i, uint64(len(m.IntervalValue)))
	i--
	dAtA[i] = 0x6a
	return len(dAtA) - i, nil
}
func (m *Value_TimeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_TimeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.TimeValue)
	copy(dAtA[i:], m.TimeValue)
	i = encodeVarintChangefeed(dAtA, i, uint64(len(m.TimeValue)))
	i--
	dAtA[i] = 0x72
	return len(dAtA) - i, nil
}
func (m *Value_UuidValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value_UuidValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.UuidValue)
	copy(dAtA[i:], m.UuidValue)
	i = encodeVarintChangefeed(dAtA, i, uint64(len(m.UuidValue)))
	i--
	dAtA[i] = 0x7a
	return len(dAtA) - i, nil
}
func (m *Key) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		keysForKey := make([]string, 0, len(m.Key))
		for k := range m.Key {
			keysForKey = append(keysForKey, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForKey)
		for iNdEx := len(keysForKey) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Key[string(keysForKey[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChangefeed(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForKey[iNdEx])
			copy(dAtA[i:], keysForKey[iNdEx])
			i = encodeVarintChangefeed(dAtA, i, uint64(len(keysForKey[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChangefeed(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Array) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Array) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Array) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChangefeed(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Decimal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintChangefeed(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		keysForValues := make([]string, 0, len(m.Values))
		for k := range m.Values {
			keysForValues = append(keysForValues, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForValues)
		for iNdEx := len(keysForValues) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Values[string(keysForValues[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChangefeed(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForValues[iNdEx])
			copy(dAtA[i:], keysForValues[iNdEx])
			i = encodeVarintChangefeed(dAtA, i, uint64(len(keysForValues[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChangefeed(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintChangefeed(dAtA []byte, offset int, v uint64) int {
	offset -= sovChangefeed(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MessageBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovChangefeed(uint64(l))
		}
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *Message_Wrapped) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Wrapped != nil {
		l = m.Wrapped.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Message_Bare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bare != nil {
		l = m.Bare.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Message_Enriched) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enriched != nil {
		l = m.Enriched.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Message_Resolved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resolved != nil {
		l = m.Resolved.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Message_BareResolved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BareResolved != nil {
		l = m.BareResolved.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *WrappedEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.Updated)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.MvccTimestamp)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}

func (m *BareEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChangefeed(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChangefeed(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChangefeed(uint64(mapEntrySize))
		}
	}
	if m.XCrdb__ != nil {
		l = m.XCrdb__.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}

func (m *BareResolved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XCrdb__ != nil {
		l = m.XCrdb__.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}

func (m *EnrichedEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovChangefeed(uint64(m.Op))
	}
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if m.TsNs != 0 {
		n += 1 + sovChangefeed(uint64(m.TsNs))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}

func (m *Resolved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Resolved)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}

func (m *EnrichedSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.ChangefeedSink)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.DbVersion)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.SourceNodeLocality)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.MvccTimestamp)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if m.TsNs != 0 {
		n += 1 + sovChangefeed(uint64(m.TsNs))
	}
	l = len(m.TsHlc)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.Origin)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if len(m.PrimaryKeys) > 0 {
		for _, s := range m.PrimaryKeys {
			l = len(s)
			n += 2 + l + sovChangefeed(uint64(l))
		}
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Updated)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.MvccTimestamp)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Value_StringValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovChangefeed(uint64(l))
	return n
}
func (m *Value_BytesValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Value_Int32Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChangefeed(uint64(m.Int32Value))
	return n
}
func (m *Value_Int64Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChangefeed(uint64(m.Int64Value))
	return n
}
func (m *Value_FloatValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *Value_DoubleValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Value_BoolValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Value_TimestampValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimestampValue != nil {
		l = m.TimestampValue.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Value_ArrayValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArrayValue != nil {
		l = m.ArrayValue.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Value_TupleValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TupleValue != nil {
		l = m.TupleValue.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Value_DecimalValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DecimalValue != nil {
		l = m.DecimalValue.Size()
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}
func (m *Value_DateValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DateValue)
	n += 1 + l + sovChangefeed(uint64(l))
	return n
}
func (m *Value_IntervalValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IntervalValue)
	n += 1 + l + sovChangefeed(uint64(l))
	return n
}
func (m *Value_TimeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimeValue)
	n += 1 + l + sovChangefeed(uint64(l))
	return n
}
func (m *Value_UuidValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UuidValue)
	n += 1 + l + sovChangefeed(uint64(l))
	return n
}
func (m *Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		for k, v := range m.Key {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChangefeed(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChangefeed(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChangefeed(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Array) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovChangefeed(uint64(l))
		}
	}
	return n
}

func (m *Decimal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChangefeed(uint64(l))
	}
	return n
}

func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for k, v := range m.Values {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChangefeed(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChangefeed(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChangefeed(uint64(mapEntrySize))
		}
	}
	return n
}

func sovChangefeed(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChangefeed(x uint64) (n int) {
	return sovChangefeed(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MessageBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, &Message{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wrapped", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WrappedEnvelope{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Message_Wrapped{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BareEnvelope{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Message_Bare{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enriched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnrichedEnvelope{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Message_Enriched{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Resolved{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Message_Resolved{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BareResolved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BareResolved{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Message_BareResolved{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrappedEnvelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrappedEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrappedEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &Record{}
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Record{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MvccTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Key{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BareEnvelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChangefeed
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChangefeed
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChangefeed
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChangefeed
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChangefeed
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChangefeed
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChangefeed
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChangefeed(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChangefeed
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Values[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XCrdb__", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.XCrdb__ == nil {
				m.XCrdb__ = &Metadata{}
			}
			if err := m.XCrdb__.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BareResolved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BareResolved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BareResolved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XCrdb__", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.XCrdb__ == nil {
				m.XCrdb__ = &Resolved{}
			}
			if err := m.XCrdb__.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnrichedEnvelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnrichedEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnrichedEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &Record{}
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Record{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Key{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsNs", wireType)
			}
			m.TsNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &EnrichedSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resolved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resolved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resolved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolved = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnrichedSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnrichedSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnrichedSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangefeedSink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangefeedSink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNodeLocality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceNodeLocality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MvccTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsNs", wireType)
			}
			m.TsNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TsNs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsHlc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TsHlc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKeys = append(m.PrimaryKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MvccTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MvccTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &Key{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Value_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &Value_BytesValue{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32Value", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int32Value{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Value", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Value_Int64Value{v}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatValue", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Value_FloatValue{float32(math.Float32frombits(v))}
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Value_DoubleValue{float64(math.Float64frombits(v))}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Value_BoolValue{b}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_TimestampValue{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Array{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_ArrayValue{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TupleValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Record{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_TupleValue{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecimalValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Value_DecimalValue{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Value_DateValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Value_IntervalValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Value_TimeValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UuidValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Value_UuidValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Key) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Key: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Key: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChangefeed
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChangefeed
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChangefeed
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChangefeed
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChangefeed
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChangefeed
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChangefeed
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChangefeed(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChangefeed
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Key[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Array) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Array: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Array: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &Value{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decimal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decimal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChangefeed
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChangefeed
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChangefeed
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChangefeed
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChangefeed
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChangefeed
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChangefeed
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChangefeed
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChangefeed
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChangefeed(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChangefeed
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Values[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChangefeed(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChangefeed
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChangefeed(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChangefeed
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChangefeed
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChangefeed
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChangefeed
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChangefeed
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChangefeed        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChangefeed          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChangefeed = fmt.Errorf("proto: unexpected end of group")
)
